name: Environment Promotion Pipeline

on:
  workflow_dispatch:
    inputs:
      source_environment:
        description: 'Source environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
      target_environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - prod
      deployment_type:
        description: 'Deployment type'
        required: true
        default: 'infrastructure'
        type: choice
        options:
          - infrastructure
          - services
          - full
      skip_tests:
        description: 'Skip integration tests'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  NODE_VERSION: '20'

jobs:
  validation:
    name: Validate Promotion Request
    runs-on: ubuntu-latest
    outputs:
      promotion_allowed: ${{ steps.validate.outputs.allowed }}
      source_env: ${{ steps.validate.outputs.source_env }}
      target_env: ${{ steps.validate.outputs.target_env }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate promotion path
        id: validate
        run: |
          SOURCE="${{ github.event.inputs.source_environment }}"
          TARGET="${{ github.event.inputs.target_environment }}"

          echo "source_env=$SOURCE" >> $GITHUB_OUTPUT
          echo "target_env=$TARGET" >> $GITHUB_OUTPUT

          # Validate promotion paths
          if [[ "$SOURCE" == "dev" && "$TARGET" == "staging" ]]; then
            echo "allowed=true" >> $GITHUB_OUTPUT
          elif [[ "$SOURCE" == "staging" && "$TARGET" == "prod" ]]; then
            echo "allowed=true" >> $GITHUB_OUTPUT
          else
            echo "allowed=false" >> $GITHUB_OUTPUT
            echo "âŒ Invalid promotion path: $SOURCE â†’ $TARGET"
            echo "Valid paths: dev â†’ staging, staging â†’ prod"
            exit 1
          fi

          echo "âœ… Validated promotion path: $SOURCE â†’ $TARGET"

  pre-deployment-tests:
    name: Pre-deployment Tests
    runs-on: ubuntu-latest
    needs: validation
    if: ${{ needs.validation.outputs.promotion_allowed == 'true' && !github.event.inputs.skip_tests }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm test

      - name: Run integration tests
        run: npm run test:integration

      - name: CDK lint and validate
        working-directory: packages/infrastructure
        run: |
          npm ci
          npm run lint
          npm run test

  promote-infrastructure:
    name: Promote Infrastructure
    runs-on: ubuntu-latest
    needs: [validation, pre-deployment-tests]
    if: |
      always() && 
      needs.validation.outputs.promotion_allowed == 'true' && 
      (needs.pre-deployment-tests.result == 'success' || needs.pre-deployment-tests.result == 'skipped') &&
      (github.event.inputs.deployment_type == 'infrastructure' || github.event.inputs.deployment_type == 'full')
    environment: ${{ needs.validation.outputs.target_env }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install CDK dependencies
        working-directory: packages/infrastructure
        run: npm ci

      - name: CDK bootstrap (if needed)
        working-directory: packages/infrastructure
        run: |
          npx cdk bootstrap aws://${{ secrets.AWS_ACCOUNT_ID }}/${{ env.AWS_REGION }} \
            --context environment=${{ needs.validation.outputs.target_env }}

      - name: Deploy parameter store
        working-directory: packages/infrastructure
        run: |
          npx cdk deploy AiValidationParameters${{ needs.validation.outputs.target_env == 'prod' && 'Prod' || (needs.validation.outputs.target_env == 'staging' && 'Staging' || 'Dev') }} \
            --context environment=${{ needs.validation.outputs.target_env }} \
            --require-approval never

      - name: Deploy infrastructure
        working-directory: packages/infrastructure
        run: |
          npx cdk deploy AiValidationPlatform${{ needs.validation.outputs.target_env == 'prod' && 'Prod' || (needs.validation.outputs.target_env == 'staging' && 'Staging' || 'Dev') }} \
            --context environment=${{ needs.validation.outputs.target_env }} \
            --require-approval never

      - name: Deploy ECS services
        working-directory: packages/infrastructure
        run: |
          npx cdk deploy AiValidationEcs${{ needs.validation.outputs.target_env == 'prod' && 'Prod' || (needs.validation.outputs.target_env == 'staging' && 'Staging' || 'Dev') }} \
            --context environment=${{ needs.validation.outputs.target_env }} \
            --require-approval never

      - name: Deploy monitoring
        working-directory: packages/infrastructure
        run: |
          npx cdk deploy AiValidationMonitoring${{ needs.validation.outputs.target_env == 'prod' && 'Prod' || (needs.validation.outputs.target_env == 'staging' && 'Staging' || 'Dev') }} \
            --context environment=${{ needs.validation.outputs.target_env }} \
            --require-approval never

  promote-services:
    name: Promote Services
    runs-on: ubuntu-latest
    needs: [validation, pre-deployment-tests, promote-infrastructure]
    if: |
      always() && 
      needs.validation.outputs.promotion_allowed == 'true' && 
      (needs.pre-deployment-tests.result == 'success' || needs.pre-deployment-tests.result == 'skipped') &&
      (needs.promote-infrastructure.result == 'success' || needs.promote-infrastructure.result == 'skipped') &&
      (github.event.inputs.deployment_type == 'services' || github.event.inputs.deployment_type == 'full')
    environment: ${{ needs.validation.outputs.target_env }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get source environment image tags
        id: get-tags
        run: |
          SOURCE_ENV="${{ needs.validation.outputs.source_env }}"
          TARGET_ENV="${{ needs.validation.outputs.target_env }}"

          # Get latest successful deployment tags from source environment
          API_TAG=$(aws ecr describe-images \
            --repository-name ai-validation-api-$SOURCE_ENV \
            --query 'sort_by(imageDetails,&imagePushedAt)[-1].imageTags[0]' \
            --output text)

          ORCHESTRATOR_TAG=$(aws ecr describe-images \
            --repository-name ai-validation-orchestrator-$SOURCE_ENV \
            --query 'sort_by(imageDetails,&imagePushedAt)[-1].imageTags[0]' \
            --output text)

          WEB_TAG=$(aws ecr describe-images \
            --repository-name ai-validation-web-$SOURCE_ENV \
            --query 'sort_by(imageDetails,&imagePushedAt)[-1].imageTags[0]' \
            --output text)

          echo "api_tag=$API_TAG" >> $GITHUB_OUTPUT
          echo "orchestrator_tag=$ORCHESTRATOR_TAG" >> $GITHUB_OUTPUT
          echo "web_tag=$WEB_TAG" >> $GITHUB_OUTPUT

          echo "ðŸ“‹ Promoting images:"
          echo "API: $API_TAG"
          echo "Orchestrator: $ORCHESTRATOR_TAG"
          echo "Web: $WEB_TAG"

      - name: Tag and push images to target environment
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          SOURCE_ENV: ${{ needs.validation.outputs.source_env }}
          TARGET_ENV: ${{ needs.validation.outputs.target_env }}
        run: |
          # API Service
          docker pull $ECR_REGISTRY/ai-validation-api-$SOURCE_ENV:${{ steps.get-tags.outputs.api_tag }}
          docker tag $ECR_REGISTRY/ai-validation-api-$SOURCE_ENV:${{ steps.get-tags.outputs.api_tag }} \
            $ECR_REGISTRY/ai-validation-api-$TARGET_ENV:${{ steps.get-tags.outputs.api_tag }}
          docker push $ECR_REGISTRY/ai-validation-api-$TARGET_ENV:${{ steps.get-tags.outputs.api_tag }}

          # Orchestrator Service
          docker pull $ECR_REGISTRY/ai-validation-orchestrator-$SOURCE_ENV:${{ steps.get-tags.outputs.orchestrator_tag }}
          docker tag $ECR_REGISTRY/ai-validation-orchestrator-$SOURCE_ENV:${{ steps.get-tags.outputs.orchestrator_tag }} \
            $ECR_REGISTRY/ai-validation-orchestrator-$TARGET_ENV:${{ steps.get-tags.outputs.orchestrator_tag }}
          docker push $ECR_REGISTRY/ai-validation-orchestrator-$TARGET_ENV:${{ steps.get-tags.outputs.orchestrator_tag }}

          # Web Service
          docker pull $ECR_REGISTRY/ai-validation-web-$SOURCE_ENV:${{ steps.get-tags.outputs.web_tag }}
          docker tag $ECR_REGISTRY/ai-validation-web-$SOURCE_ENV:${{ steps.get-tags.outputs.web_tag }} \
            $ECR_REGISTRY/ai-validation-web-$TARGET_ENV:${{ steps.get-tags.outputs.web_tag }}
          docker push $ECR_REGISTRY/ai-validation-web-$TARGET_ENV:${{ steps.get-tags.outputs.web_tag }}

      - name: Update ECS service tasks
        env:
          TARGET_ENV: ${{ needs.validation.outputs.target_env }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          # Update API service
          aws ecs update-service \
            --cluster ai-validation-$TARGET_ENV \
            --service ai-validation-api-$TARGET_ENV \
            --force-new-deployment

          # Update Orchestrator service
          aws ecs update-service \
            --cluster ai-validation-$TARGET_ENV \
            --service ai-validation-orchestrator-$TARGET_ENV \
            --force-new-deployment

          # Update Web service
          aws ecs update-service \
            --cluster ai-validation-$TARGET_ENV \
            --service ai-validation-web-$TARGET_ENV \
            --force-new-deployment

  post-deployment-validation:
    name: Post-deployment Validation
    runs-on: ubuntu-latest
    needs: [validation, promote-infrastructure, promote-services]
    if: always() && (needs.promote-infrastructure.result == 'success' || needs.promote-services.result == 'success')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for services to stabilize
        run: |
          TARGET_ENV="${{ needs.validation.outputs.target_env }}"
          echo "â³ Waiting for services in $TARGET_ENV to stabilize..."

          # Wait for API service
          aws ecs wait services-stable \
            --cluster ai-validation-$TARGET_ENV \
            --services ai-validation-api-$TARGET_ENV

          # Wait for Orchestrator service
          aws ecs wait services-stable \
            --cluster ai-validation-$TARGET_ENV \
            --services ai-validation-orchestrator-$TARGET_ENV

          # Wait for Web service
          aws ecs wait services-stable \
            --cluster ai-validation-$TARGET_ENV \
            --services ai-validation-web-$TARGET_ENV

          echo "âœ… All services are stable"

      - name: Run smoke tests
        run: |
          TARGET_ENV="${{ needs.validation.outputs.target_env }}"

          # Get ALB endpoint
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names ai-validation-alb-$TARGET_ENV \
            --query 'LoadBalancers[0].DNSName' \
            --output text)

          echo "ðŸ§ª Running smoke tests against: $ALB_DNS"

          # Health check
          curl -f "http://$ALB_DNS/health" || exit 1
          echo "âœ… Health check passed"

          # API health check
          curl -f "http://$ALB_DNS/api/health" || exit 1
          echo "âœ… API health check passed"

          # Detailed health check
          curl -f "http://$ALB_DNS/api/health/detailed" || exit 1
          echo "âœ… Detailed health check passed"

  notification:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: [validation, promote-infrastructure, promote-services, post-deployment-validation]
    if: always()
    steps:
      - name: Determine status
        id: status
        run: |
          if [[ "${{ needs.post-deployment-validation.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=âœ…" >> $GITHUB_OUTPUT
            echo "message=Successfully promoted from ${{ needs.validation.outputs.source_env }} to ${{ needs.validation.outputs.target_env }}" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=âŒ" >> $GITHUB_OUTPUT
            echo "message=Failed to promote from ${{ needs.validation.outputs.source_env }} to ${{ needs.validation.outputs.target_env }}" >> $GITHUB_OUTPUT
          fi

      - name: Create deployment status
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ steps.status.outputs.status }}';
            const emoji = '${{ steps.status.outputs.emoji }}';
            const message = '${{ steps.status.outputs.message }}';

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.payload.deployment?.id || 0,
              state: status === 'success' ? 'success' : 'failure',
              description: `${emoji} ${message}`,
              environment: '${{ needs.validation.outputs.target_env }}'
            });
